







$ node spin1.js
$ node spin2.js
$ node spin3.js
$ node spin4.js
$ node spin5.js
$ node spin6.js

(location bar) page1.html
(location bar) page2.html
(location bar) page3.html
(location bar) page4.html

$ npm run electron-page page1.html
$ npm run electron-page page2.html
$ npm run electron-page page3.html
$ npm run electron-page page4.html







node/chrome/firefox/ie/electron
does it work?
does it stop the clock?
what's the count?






ok, so that's all great
next up, make the vue demo which is the same as page3 but all in vue
use the production verson of vue in case that matters

then make the crazy one with a button that makes another 100 counters that count forever up

is vue using requestAnimationFrame already?
that would be great, because then you wouldn't have to
write an example that shows whether this is the case or not

how would you measure how much time the browser is spending updating things?
if you could measure this, then you could scale back the update frequency when time gets tighter
















>notes when you thought you were back to jquery and handlebars

so maybe you're back to jquery and handlebars
and also, maybe this isn't that bad or that hard

a little part of the page is made of these parts
-a template
-a unique id, generated by makeUnique, and kept
-custom data that fills the template (raw data and rendered text)
-new custom data that should fill the template (raw data and rendered text) (maybe the text renderer is in here as a method, too)

you don't have dom diffing, but maybe you do'n tneed it
all you have to do is compare the custom data with the new custom data
the program can change new custom data as frequently as it wants, and it can do this quickly
and then periodically, 

the program keeps a global list of all the divs that are on the page, and they of course have unique ids
it runs down this list, comparing the data, and updating the div if necessary

and for now, don't worry about advanced features like
-optimizing to just show divs that are both on the page and visible on the screen
-throttling the refresh rate up and down depending on how complex the page is or how long it takes
instead, just update every div on the page, visible or not, and do it 60fps
this might be all you need ever, even

upside is now you can throw in and change whatever arbitrary text html you want, and at any time, rather than having a heirarchy of structure like vue wants
one of the kinds of components will just be a container, a div with an id, which you can add items to the start or end of, or clear and setup again entirely
it's ok if the page blinks when sorting, for instance
you'll have to figure out input controls like text boxes and buttons, and they'll likely have global ids, but having everything with a globally unique id might be easier because then you don't have the heirarchy of scope thing that react and vue like so much
you'll have to figure out how to keep the scroll position of different tabs
you probably should never show 10k items, and instead have pagination and an instant filter style search box when that happens
this is kind of an interesting challenge to design now




















